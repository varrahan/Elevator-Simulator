#include "ElevatorSubsystem.h"
#include <iostream>
#include <thread>

/**
 * Constructor for ElevatorSubsystem
 * @param s Reference to the Scheduler
 * @param id The ID for this elevator
 * @param port The UDP port to listen on
 */
ElevatorSubsystem::ElevatorSubsystem(Scheduler& s, int id, int port) 
    : scheduler(s), mtx(), elevatorId(id), receiveSocket(port), sendSocket() {
    
    // Create an elevator
    elevator = std::make_unique<Elevator>(*this, elevatorId);  

    // Create an elevator thread 
    std::cout << "Created elevator " << elevatorId << " on port " << port << std::endl;
    elevatorThread = std::thread(&Elevator::run, elevator.get());
}

void ElevatorSubsystem::removeElevator() {
    scheduler.removeElevator(elevatorId);
}

bool ElevatorSubsystem::receiveEvent(Event& event) {
    try {
        std::vector<uint8_t> data(100);
        DatagramPacket packet(data, data.size());
        // Non-blocking check
        if (scheduler.isFinish()) return false;

        // Receive the packet
        receiveSocket.receive(packet);

        event = Event::bytes_to_event(data);
        // Make sure this event is for this elevator
        return (event.assignedElevator == elevatorId);
    } catch (const std::exception& e) {
        std::cerr << "Error receiving event: " << e.what() << std::endl;
        return false;
    }
}

/**
 * Send a response via UDP
 * @param response The response to send
 */
void ElevatorSubsystem::sendResponse(const Event& response) {
    try {
        // Serialize the response
        std::vector<uint8_t> data = response.event_to_bytes();
        
        // Create and send the packet to the scheduler
        DatagramPacket packet(data, data.size(), InetAddress::getLocalHost(), SCHEDULER_PORT);
        sendSocket.send(packet);
        
        std::cout << "Elevator subsystem " << elevatorId << " sent response to scheduler" << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "Error sending response: " << e.what() << std::endl;
    }
}

/**
 * Adds an elevator response event to the scheduler
 * @param response The response event generated by the elevator
 */
void ElevatorSubsystem::addElevatorResponse(Event response) {
    sendResponse(response);
    cv.notify_all();  
}

/**
 * Checks if the scheduler has finished processing all events
 * @return True if the scheduler is finished, otherwise false
*/
bool ElevatorSubsystem::isFinish(){
    return scheduler.isFinish();
}

/**
 * Main loop for the elevator subsystem to process events
 * Continuously fetches events from the scheduler and assigns them to the elevator
*/
void ElevatorSubsystem::run() {
    while (!scheduler.isFinish()) {
        Event event;     
        if (receiveEvent(event)){
            std::cout << "ElevatorSubsystem " << elevatorId << " received event, Time=" << event.time 
                     << ", Source=" << event.source << std::endl;

            std::lock_guard<std::mutex> lock(elevator->mtx);
            elevator->setEvent(event);
            elevator->cv.notify_all(); // Notify elevator
        }
        // Small delay to prevent busy waiting
        std::this_thread::sleep_for(std::chrono::milliseconds(5));
    }
}

/**
 * Destructor for ElevatorSubsystem
 */
ElevatorSubsystem::~ElevatorSubsystem() {
    if (elevatorThread.joinable()){
        elevatorThread.join();
    }
}


/**
 * Moves the elevator to the specified destination floor
 * @param dstn The destination floor
 * @return If move to was successfull
 */
bool Elevator::moveTo(int dstn) {
    if (curr_floor == dstn) {
        state = elevatorState::ELEVATOR_REST;
        return true;
    }
    // Set the appropriate movement state
    state = (dstn > curr_floor) ? elevatorState::ELEVATOR_MOVING_UP : elevatorState::ELEVATOR_MOVING_DOWN;
    
    // Send state update to scheduler immediately when we start moving
    std::string stateString = (state == elevatorState::ELEVATOR_MOVING_UP) ? "UP" : "DOWN";
    std::string source = "Elevator: " + std::to_string(elevatorId);
    Event stateUpdate{
        event.time,
        source,
        stateString,
        0, // No elevator button pressed
        false, // Not from floor
        elevatorId,
        curr_floor,
        passengers,
        false, // Not a completion message
        event.fault
    };
    elevatorSubsystem.addElevatorResponse(stateUpdate);
    
    std::cout << "Elevator " << elevatorId << " is moving from " << curr_floor << " to " << dstn << "." << std::endl;
    
    // Check for fault with this part
    if(event.fault == ELEVATOR_STUCK) {
        // Make timer go off before getting to destination
        std::this_thread::sleep_for(std::chrono::seconds(moveBetweenFloorsTime(dstn) - 3));
        std::cout << "Timer went off!"<< std::endl;
        std::cout << "Elevator " << elevatorId << " got stuck while moving from " << curr_floor << " to " << dstn << "." << std::endl;
        return false;
        
    }
    else if(event.fault == ARRIVAL_SENSOR_ISSUE) {
        // Make timer go off before getting to destination
        std::this_thread::sleep_for(std::chrono::seconds(moveBetweenFloorsTime(dstn) - 3));
        std::cout << "Timer went off!"<< std::endl;
        std::cout << "Elevator " << elevatorId << " received an issue with the arrival sensor while moving from " << curr_floor << " to " << dstn << "." << std::endl;
        return false;
    }
    else {
        // Travel to floor
        std::this_thread::sleep_for(std::chrono::seconds(moveBetweenFloorsTime(dstn))); 
    }

    // Update position and state
    state = elevatorState::ELEVATOR_REST;
    curr_floor = dstn; 
    
    Event positionUpdate{
        event.time,
        source,
        "", // Empty string for the floorButton to indicate REST state
        0,
        false,
        elevatorId,
        curr_floor,
        passengers,
        false,
        event.fault
    };
    elevatorSubsystem.addElevatorResponse(positionUpdate);

    return true;
} 

/**
 * Calculate move time between floors
 * @param dstn The destination floor level
 * @return The time to move between floors
 */
int Elevator::moveBetweenFloorsTime(int dstn) {
    int floorsToMove = std::abs(dstn - curr_floor);
    if(floorsToMove == 1) {
        return TIME_BTWN_1_FLOOR;
    }
    else if(floorsToMove == 2) {
        return TIME_BTWN_2_FLOORS;
    }
    else if(floorsToMove == 3) {
        return TIME_BTWN_3_FLOORS;
    }
    else {
        return floorsToMove * TIME_BTWN_X_FLOORS_PER_FLOOR;
    }
}

/**
 * Simulates opening elevator doors
 */
void Elevator::openDoors() {
    std::cout << "Elevator " << elevatorId << " is opening doors at floor #" << curr_floor << "." << std::endl;
    std::this_thread::sleep_for(std::chrono::seconds(TIME_TO_OPEN_CLOSE_DOOR)); 
    // Check for fault for this part
    if(event.fault != DOOR_CLOSE_STUCK) {
        state = ELEVATOR_DOOR_OPEN; 
    }
    else {
        std::cout << "Elevator " << elevatorId << " doors are stuck closed at floor #" << curr_floor << "." << std::endl;
        std::cout << "Elevator " << elevatorId << " is recovering from doors being stuck at floor #" << curr_floor << "." << std::endl;
        std::this_thread::sleep_for(std::chrono::seconds(RECOVERY_TIME)); 
        std::cout << "Elevator " << elevatorId << " has recovered and doors are opened at floor #" << curr_floor << "." << std::endl;
        state = ELEVATOR_DOOR_OPEN; 
    }
}

/**
 * Simulates closing elevator doors
 */
void Elevator::closeDoors() {
    std::cout << "Elevator " << elevatorId << " is closing doors at floor #" << curr_floor << "." << std::endl;
    std::this_thread::sleep_for(std::chrono::seconds(TIME_TO_OPEN_CLOSE_DOOR)); 
    // Check for fault for this part
    if(event.fault != DOOR_OPEN_STUCK) {
        state = ELEVATOR_DOOR_CLOSE; 
    }
    else {
        std::cout << "Elevator " << elevatorId << " doors are stuck open at floor #" << curr_floor << "." << std::endl;
        std::cout << "Elevator " << elevatorId << " is recovering from doors being stuck at floor #" << curr_floor << "." << std::endl;
        std::this_thread::sleep_for(std::chrono::seconds(RECOVERY_TIME)); 
        std::cout << "Elevator " << elevatorId << " has recovered and doors are closed at floor #" << curr_floor << "." << std::endl;
        state = ELEVATOR_DOOR_CLOSE; 
    }
}

/**
 * Load passenger
 */
void Elevator::load() { 
    std::cout << "Elevator " << elevatorId << " is loading at floor #" << curr_floor << "." << std::endl;
    std::this_thread::sleep_for(std::chrono::seconds(TIME_TO_LOAD_UNLOAD_1_PASSENGER)); 
    passengers++;
    totalPassengers++; 
}

/**
 * Unload passenger
 */
void Elevator::unload() { 
    std::cout << "Elevator " << elevatorId << " is unloading at floor #" << curr_floor << "." << std::endl;
    std::this_thread::sleep_for(std::chrono::seconds(TIME_TO_LOAD_UNLOAD_1_PASSENGER)); 
    passengers--;
}

/**
 * Constructor for the Elevator class.
 * @param elevatorSubsystem_a Reference to the ElevatorSubsystem
 * @param id Elevator id
 */
Elevator::Elevator(ElevatorSubsystem& elevatorSubsystem_a, int id) 
    : elevatorSubsystem(elevatorSubsystem_a), elevatorId(id), 
      state(elevatorState::ELEVATOR_REST), event(Event{}), curr_floor(1),
      passengers(0), totalPassengers(0) {}

/**
 * Sets the current event for the elevator
 * @param event The event to be processed by the elevator
 */
void Elevator::setEvent(Event event) {
    this->event = event;
}

/**
 * Main loop for the elevator to process assigned events
 * Waits for an event, processes it by moving and opening/closing doors, then sends a response
 */
void Elevator::run() {
    while (!elevatorSubsystem.isFinish()) {
        // Wait until there is an event  
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, [this] { return !event.source.empty(); });

        if (event.isFromFloor) {
            // Process the event
            std::cout << "Elevator " << elevatorId << " processing event: Time=" << event.time 
                      << ", Source=" << event.source 
                      << ", Floor Button=" << event.floorButton 
                      << ", Elevator Button=" << event.elevatorButton << std::endl;
            
            // Parse floor number from source
            int sourceFloor = std::stoi(event.source);
            

            // First, make sure doors are closed
            if (state == elevatorState::ELEVATOR_DOOR_OPEN) {
                closeDoors();
            }
            
            // Go to the source floor
            bool success = moveTo(sourceFloor);  
            if(success == false) {
                std::string source = "Elevator" + std::to_string(elevatorId);
                Event faultResponse{
                    event.time,
                    source,
                    event.floorButton,
                    event.elevatorButton,
                    false,           // Not from floor
                    elevatorId,      // This elevator
                    curr_floor,      // Current floor
                    passengers,      // Current passengers
                    true,             // This is a completion message!
                    event.fault       // Fault for system
                };
                faultResponse.isComplete = true;
                std::cout << "Elevator " << elevatorId << " fault occured while going from floor "
                          << sourceFloor << " to floor " << event.elevatorButton << std::endl;
                std::cout << "Force termination of elevator " << elevatorId << " and it's event." << std::endl;
                elevatorSubsystem.removeElevator();
                elevatorSubsystem.addElevatorResponse(faultResponse);
                break;
            }

            // Open doors
            openDoors(); 

            // Load elevator
            load();

            // Close doors
            closeDoors();
            
            // Go to the destination floor
            success = moveTo(event.elevatorButton);
            if(success == false) {
                std::string source = "Elevator" + std::to_string(elevatorId);
                Event faultResponse{
                    event.time,
                    source,
                    event.floorButton,
                    event.elevatorButton,
                    false,           // Not from floor
                    elevatorId,      // This elevator
                    curr_floor,      // Current floor
                    passengers,      // Current passengers
                    true,             // This is a completion message!
                    event.fault       // Fault for system
                };
                faultResponse.isComplete = true;
                std::cout << "Elevator " << elevatorId << " fault occured while going from floor "
                          << sourceFloor << " to floor " << event.elevatorButton << std::endl;
                std::cout << "Force termination of elevator " << elevatorId << " and it's event." << std::endl;
                elevatorSubsystem.removeElevator();
                elevatorSubsystem.addElevatorResponse(faultResponse);
                break;
            }

            // Open Doors
            openDoors(); 

            // Unload elevator 
            unload();

            // Close doors
            closeDoors(); 

            // IMPORTANT: Send final completion response
            std::string source = "Elevator" + std::to_string(elevatorId);
            Event completionResponse{
                event.time,
                source,
                event.floorButton,
                event.elevatorButton,
                false,           // Not from floor
                elevatorId,      // This elevator
                curr_floor,      // Current floor
                passengers,      // Current passengers
                true,             // This is a completion message!
                event.fault       // Fault for system
            };
            completionResponse.isComplete = true;
            
            // Send explicit completion notification
            std::cout << "Elevator " << elevatorId << " completed request from floor "
                      << sourceFloor << " to floor " << event.elevatorButton << std::endl;
            elevatorSubsystem.addElevatorResponse(completionResponse);

            // Reset event after processing
            this->event = Event{};
        }
    }
    std::cout << "Exiting elevator " << elevatorId << std::endl;
}